<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Byldr Engine - Centrov√°n√≠ na m≈ô√≠≈æku</title>
    <style>
        :root { 
            --accent: #007aff; 
            --bg-ui: rgba(28, 28, 30, 0.9);
            --bg-btn: rgba(255, 255, 255, 0.1);
            --text: #ffffff;
        }
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; outline: none; }
        body { 
            margin: 0; overflow: hidden; background: #1c1c1e; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; user-select: none;
        }
        
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; display: none; }
        
        .overlay { 
            position: fixed; inset: 0; background: #000; z-index: 100; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; color: #fff;
        }

        .top-container {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; align-items: center; gap: 10px; pointer-events: auto;
        }

        .main-bar {
            background: var(--bg-ui); backdrop-filter: blur(20px);
            padding: 8px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.15);
            display: flex; align-items: center; gap: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        #stats-card {
            background: rgba(0,0,0,0.3); padding: 4px 12px;
            border-radius: 12px; color: var(--text);
            font-size: 11px; font-weight: 700;
        }
        
        .tool-btn {
            width: 44px; height: 44px; border-radius: 12px; border: none;
            background: var(--bg-btn); color: #fff; font-size: 18px;
            display: flex; align-items: center; justify-content: center;
        }
        .tool-btn.active { background: var(--accent); }

        #color-preview { width: 20px; height: 20px; border-radius: 4px; border: 2px solid #fff; }

        #joy-container { position: absolute; bottom: 40px; left: 40px; width: 100px; height: 100px; pointer-events: auto; }
        #jump-wrapper { position: absolute; bottom: 40px; right: 40px; pointer-events: auto; }
        
        .jump-btn {
            width: 70px; height: 70px; border-radius: 35px;
            background: var(--bg-ui); border: 1px solid rgba(255,255,255,0.1);
            color: #fff; font-size: 28px; display: flex; align-items: center; justify-content: center;
        }

        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 4px; height: 4px; background: #fff; border-radius: 50%;
        }
    </style>
</head>
<body>

    <div id="start-screen" class="overlay">
        <h1 style="letter-spacing: -1px;">BYLDR PRO</h1>
        <button id="start-btn" class="tool-btn" style="width: 140px; height: 50px; background: var(--accent); font-weight: bold;">SPUSTIT</button>
    </div>

    <div id="ui">
        <div class="top-container">
            <div class="main-bar">
                <div id="stats-card"><span id="count">0</span> D√çLK≈Æ</div>
                <button id="mode-build" class="tool-btn active">üß±</button>
                <button id="mode-erase" class="tool-btn">üßπ</button>
                <button id="btn-color" class="tool-btn"><div id="color-preview"></div></button>
                <button id="btn-undo" class="tool-btn">‚Ü∫</button>
            </div>
        </div>
        <div id="crosshair"></div>
        <div id="joy-container"></div>
        <div id="jump-wrapper"><button id="jump-btn" class="jump-btn">‚Üë</button></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <script>
        const COLORS = [0x007aff, 0xff3b30, 0x34c759, 0xffcc00, 0xaf52de, 0xffffff, 0x1c1c1e];
        const BRICK_W = 1.0;
        const BRICK_H = 1.2; 
        const PLAYER_EYE_H = 2.0; 
        const PLAYER_RADIUS = 0.35;

        let scene, camera, renderer, raycaster, clock;
        let ghost, gridBox, floor;
        let bricks = [], state = { mode: 'BUILD', colorIdx: 0, move: {x:0, y:0}, rot: {y:0, p:0}, vel: new THREE.Vector3(), canJump: false };

        const brickGeo = new THREE.BoxGeometry(BRICK_W, BRICK_H, BRICK_W);
        const studGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.15, 12);

        function createGridTexture() {
            const size = 128; // Vy≈°≈°√≠ rozli≈°en√≠ pro ƒçist≈°√≠ ƒç√°ry
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#888888';
            ctx.fillRect(0, 0, size, size);

            // ƒå√°ra m≈ô√≠≈æky - tvo≈ô√≠ okraj pol√≠ƒçka
            ctx.strokeStyle = '#555555';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, size, size);

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(200, 200); 
            return texture;
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0a0a8);
            scene.fog = new THREE.Fog(0xa0a0a8, 15, 60);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0.5, PLAYER_EYE_H, 5.5); 
            camera.rotation.order = 'YXZ';

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(10, 20, 15);
            sun.castShadow = true;
            scene.add(sun);

            // PODLAHA: Odstranƒõn offset, aby (0,0) byl poƒç√°tkem ƒçtverce
            const floorMat = new THREE.MeshStandardMaterial({ 
                map: createGridTexture(),
                roughness: 0.8
            });
            floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            updateGhost();
            
            const edgeGeo = new THREE.EdgesGeometry(brickGeo);
            gridBox = new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 }));
            scene.add(gridBox);

            raycaster = new THREE.Raycaster();
            clock = new THREE.Clock();

            setupControls();
            updateUI();
            animate();
        }

        function createBrick(color, isGhost = false) {
            const group = new THREE.Group();
            const mat = isGhost ? 
                new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 }) : 
                new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.1 });
            
            const body = new THREE.Mesh(brickGeo, mat);
            const stud = new THREE.Mesh(studGeo, mat);
            stud.position.y = BRICK_H / 2 + 0.075;
            
            if(!isGhost) {
                body.castShadow = body.receiveShadow = true;
                stud.castShadow = stud.receiveShadow = true;
                body.scale.set(0.99, 0.99, 0.99); 
            }
            
            group.add(body, stud);
            return group;
        }

        function updateGhost() {
            if(ghost) scene.remove(ghost);
            ghost = createBrick(COLORS[state.colorIdx], true);
            scene.add(ghost);
        }

        function checkCollisions(targetPos) {
            for (let brick of bricks) {
                const dx = Math.abs(targetPos.x - brick.position.x);
                const dz = Math.abs(targetPos.z - brick.position.z);
                if (dx < (BRICK_W / 2 + PLAYER_RADIUS) && dz < (BRICK_W / 2 + PLAYER_RADIUS)) {
                    const playerFeet = targetPos.y - PLAYER_EYE_H;
                    const brickTop = brick.position.y + BRICK_H / 2;
                    const brickBottom = brick.position.y - BRICK_H / 2;
                    if (playerFeet < brickTop && targetPos.y > brickBottom) return true;
                }
            }
            return false;
        }

        function setupControls() {
            nipplejs.create({ zone: document.getElementById('joy-container'), mode: 'static', position: {left:'50px', bottom:'50px'}, size: 80 })
                .on('move', (e, d) => { state.move = { x: d.vector.x, y: d.vector.y }; })
                .on('end', () => { state.move = { x: 0, y: 0 }; });

            let lx, ly, isDragging = false, dragMoved = 0;
            window.addEventListener('touchstart', e => { 
                if(e.target.closest('button, #joy-container')) return;
                isDragging = true; dragMoved = 0;
                lx = e.touches[0].pageX; ly = e.touches[0].pageY;
            });
            window.addEventListener('touchmove', e => {
                if(!isDragging) return;
                const dx = e.touches[0].pageX - lx;
                const dy = e.touches[0].pageY - ly;
                state.rot.y -= dx * 0.005;
                state.rot.p = Math.max(-1.5, Math.min(1.5, state.rot.p - dy * 0.005));
                dragMoved += Math.abs(dx) + Math.abs(dy);
                lx = e.touches[0].pageX; ly = e.touches[0].pageY;
            });
            window.addEventListener('touchend', () => { if(isDragging && dragMoved < 15) handleInteraction(); isDragging = false; });

            document.getElementById('mode-build').onclick = () => setMode('BUILD');
            document.getElementById('mode-erase').onclick = () => setMode('ERASE');
            document.getElementById('btn-color').onclick = () => { state.colorIdx = (state.colorIdx + 1) % COLORS.length; updateGhost(); updateUI(); };
            document.getElementById('btn-undo').onclick = () => { const b = bricks.pop(); if(b) scene.remove(b); updateUI(); };
            document.getElementById('jump-btn').onclick = () => { if(state.canJump) { state.vel.y = 10; state.canJump = false; } };
        }

        function setMode(m) {
            state.mode = m;
            document.getElementById('mode-build').className = 'tool-btn' + (m==='BUILD'?' active':'');
            document.getElementById('mode-erase').className = 'tool-btn' + (m==='ERASE'?' active':'');
        }

        function handleInteraction() {
            if(state.mode === 'BUILD') {
                if(!ghost.visible) return;
                const b = createBrick(COLORS[state.colorIdx]);
                b.position.copy(ghost.position);
                scene.add(b);
                bricks.push(b);
            } else {
                raycaster.setFromCamera({x:0, y:0}, camera);
                const hits = raycaster.intersectObjects(bricks, true);
                if(hits.length > 0) {
                    let target = hits[0].object;
                    while(target.parent && target.parent !== scene) target = target.parent;
                    scene.remove(target);
                    bricks = bricks.filter(b => b !== target);
                }
            }
            updateUI();
        }

        function updateUI() {
            document.getElementById('color-preview').style.backgroundColor = '#' + COLORS[state.colorIdx].toString(16).padStart(6, '0');
            document.getElementById('count').innerText = bricks.length;
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);
            
            camera.rotation.set(state.rot.p, state.rot.y, 0);
            const fwd = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), state.rot.y);
            const rgt = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), state.rot.y);
            const moveInput = fwd.multiplyScalar(state.move.y * 7).add(rgt.multiplyScalar(state.move.x * 7));
            
            state.vel.y -= 25 * dt;
            
            let nextPosX = camera.position.clone();
            nextPosX.x += moveInput.x * dt;
            if (!checkCollisions(nextPosX)) camera.position.x = nextPosX.x;

            let nextPosZ = camera.position.clone();
            nextPosZ.z += moveInput.z * dt;
            if (!checkCollisions(nextPosZ)) camera.position.z = nextPosZ.z;

            camera.position.y += state.vel.y * dt;
            
            let grounded = false;
            if(camera.position.y < PLAYER_EYE_H) {
                camera.position.y = PLAYER_EYE_H;
                state.vel.y = 0;
                grounded = true;
            }

            for (let brick of bricks) {
                const dx = Math.abs(camera.position.x - brick.position.x);
                const dz = Math.abs(camera.position.z - brick.position.z);
                const brickTop = brick.position.y + BRICK_H / 2 + PLAYER_EYE_H;
                if (dx < BRICK_W / 2 + 0.2 && dz < BRICK_W / 2 + 0.2) {
                    if (camera.position.y < brickTop && camera.position.y > brickTop - 0.5) {
                        camera.position.y = brickTop;
                        state.vel.y = 0;
                        grounded = true;
                    }
                }
            }
            state.canJump = grounded;

            raycaster.setFromCamera({x:0, y:0}, camera);
            const hits = raycaster.intersectObjects([floor, ...bricks], true);
            
            if(hits.length > 0 && state.mode === 'BUILD') {
                ghost.visible = gridBox.visible = true;
                const hit = hits[0];
                const norm = hit.face.normal.clone().transformDirection(hit.object.matrixWorld);
                const pos = hit.point.clone().add(norm.multiplyScalar(0.1));
                
                // OPRAVENO: Snapping na st≈ôed ƒçtverce
                // Math.floor(pos.x) najde lev√Ω okraj ƒçtverce, +0.5 ho posune do st≈ôedu
                const gx = Math.floor(pos.x) + 0.5;
                const gz = Math.floor(pos.z) + 0.5;
                const gy = Math.floor(pos.y / BRICK_H) * BRICK_H + (BRICK_H / 2);
                
                ghost.position.set(gx, gy, gz);
                gridBox.position.set(gx, gy, gz);
            } else {
                ghost.visible = gridBox.visible = false;
            }

            renderer.render(scene, camera);
        }

        document.getElementById('start-btn').onclick = () => {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            init();
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

